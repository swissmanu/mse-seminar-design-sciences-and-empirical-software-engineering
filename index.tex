\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.1}


\begin{document}
\begin{centering}
	\Large{Master Seminar}
	\par
	\Huge{Design Sciences and\\Empirical Software Engineering}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Olaf Zimmermann\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{2ex}

		\small{
			\textbf{Keywords}: Design Science, Empirical Software Engineering, FAIR Research Principles, Reactive Programming, Object Oriented Programming
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}
Solving unique problems through the application of software engineering principles does not automatically lead to unique solutions in general. In fact, the emergence of recurring design patterns can be observed. Salvaneschi et al. \cite{7827078} challenge the observer pattern \cite{gamma1995design} and its impact on source code comprehensibility in comparison to the usage of reactive programming \emph{(RP)}.

We will examine the paper \emph{On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study} by Salvaneschi et al. \cite{7827078} and answer two sets of research questions within this paper. With the focus on design sciences and empirical software engineering methods, set \emph{RQ1} considers the following three questions:

\begin{itemize}
	\item \emph{RQ1.1: Which empirical research methods, approaches and concepts were applied?}
	\item \emph{RQ1.2: Are these research methods, approaches and concepts applied well, what could have been done better?}
	\item \emph{RQ1.3: Does the paper meet FAIR principles \cite{2019arXiv190805986H} \cite{wilkinson:2016}?}
\end{itemize}

As the paper further compares RP with the observer design pattern \cite{gamma1995design}, an equivalent based on object oriented programming \emph{(OOP)} paradigms, question set \emph{RQ2} reviews software engineering specific aspects of that comparison:

\begin{itemize}
	\item \emph{RQ2.1: How does the paper define RP and OOP?}
	\item \emph{RQ2.2: When should RP be considered, and when not?}
	\item \emph{RQ2.3: Which experiments should be conducted in future work?}
	\item \emph{RQ2.4: Which design alternatives exist (in a particular application context)?}
\end{itemize}

However, we will not review the papers application of statistical methods since this is out of scope.

In the following we will introduce and clarify important terms. Section 2 and 3 will examine the mentioned paper more closely and answer \emph{RQ1} and \emph{RQ2.1}. The questions \emph{RQ2.2} through \emph{RQ2.4} will be tackled in section 4 where we discuss earlier findings.

\subsection{Empirical Software Engineering}
Software engineering applies engineering principles when working with software artifacts \cite{159342} throughout their life cycle. Although ``\emph{the application of a systematic, disciplined, quantifiable approach to the development (\dots) of software (\dots)}'' \cite{159342} may rightful restrain us methodically, it is agreed upon that the process leading to a software product is of creative nature \cite{8051350}. It is this creative environment that keep the fundamental building blocks of software development, maintenance and operation in a constant flux of change. As tools and methods keep changing \cite{kapferer:2019:empirical}, software engineering organizations need to adapt to new circumstances often. Kapferer \cite{kapferer:2019:empirical} highlights in his introduction to empirical software engineering how the exertion of continuous quality improvement procedures like \emph{Plan/Do/Study/Act} \cite{deming} or an agile project setup like \emph{Scrum} leads to the controlled adoption of such. A reliable benchmark allows an organization to estimate feasibility of a new method or tool in advance as well as measure impact after its implementation.

Hence software engineering problems lack analytical and scientific formalism, empirical software engineering applies empirical research methods in software engineering to yield a representative benchmark for a problem domain.

\subsection{Design Science}

Roel J. Wieranga derives guidelines specifically for software engineering research projects from design science in his book \emph{Design Science Methodology for Information Systems and Software Engineering} \cite{wieringa}. As Balestra \cite{balestra:2019:designscience:articactandcontext} summarizes in his paper about design science and their application in software projects, Wieranga \cite{wieringa} defines an iterative process consisting of a \emph{design} and \emph{investigation} step. During \emph{design}, an \emph{artifact} is designed to satisfy the goals of one or more \emph{stakeholders} under consideration of a specific \emph{knowledge context}. The artifact and context is then put under \emph{investigation} to answer knowledge questions. These answers lead to a feedback loop where gained insights get fed into another design iteration. This process might be repeated until the stakeholder goals are met at a satisfying level.

\subsection{FAIR Research Principles}
\emph{FAIR} is an abbreviation for Findability, Accessibility, Interoperability and Reusability. It was first introduced by Mark. D. Wilkinson et al. in March 2016 \cite{wilkinson:2016} and describes guidelines to foster digital research objects over the long-term. The guidelines want to maximization the value of research results for the science community as a whole. Following a summary of the four cornerstones:

\begin{itemize}
	\item \emph{Findability}: Objects are annotated with well-defined meta information. This information is usable for both humans and machines. An example is a globally unique, persistent identifier for a publicized paper or keywords highlighting the problem domains of a research result. There is a catalogue which provides searchable access to this meta information.
	\item \emph{Accessibility}: Digital objects can be retrieved using an open, standardized communication protocol. It provides ways to authenticate and/or authorize users (again both humans and machines) if necessary. Meta information is always available, even if the actual object is not anymore.
	\item \emph{Interoperability}: Meta information and the object it describes use formats and vocabularies following FAIR principles. For example an accepted, domain specific terminology is used or a data set collected during an experiment is available in XML format, alongside with a schema \footnote{\url{https://www.w3.org/TR/xmlschema-1/}} describing its structure. Referenced research results are part of the meta information.
	\item \emph{Reusability}: Research results meet the respective science communities standards. Further results are released under a concise and accessible data usage license to simplify their reuse in follow-up research projects.
\end{itemize}

Hasselbring et al. \cite{2019arXiv190805986H} transfer the general applicable guidelines to the field of computer science research and formulate domain specific recommendations. Their key point is the request for treating software artifacts produced during a research project with the same level of care as the project report itself. Platforms like Zenodo\footnote{\url{https://zenodo.org}} in conjunction with GitHub\footnote{\url{https://github.com}} allow to reference, archive and later retrieve associated software artifacts for example.

\subsection{Reactive Programming}
RP is a declarative programming paradigm. In contrary to imperative programming, declarative code describes \emph{what} should be achieved rather than \emph{how} the process leading to that result looks like. With RP, we describe values, their transformation over time and how they depend on each other \cite{8354906}. A runtime system propagates changed values to their relevant dependencies, execute declared computations and ensures always a consistent state.

\begin{listing}[H]
	\begin{minted}{JavaScript}
		// TODO Example RP
	\end{minted}
	\caption{}
	\label{lst:basic-rp-with-rxjs}
\end{listing}

\subsection{Observer Design Pattern}
When dividing a large component into smaller sub components, we usually want these components to be as isolated as necessary so they become more reusable, hence target for loose coupling between them. Still, the new components need a way to interact with each other.

The observer pattern \cite{gamma1995design} deeply rooted in OOP defines an interface where \emph{observers} can subscribe to state change notifications of a \emph{subject}. Once notified, an \emph{observer} might query the \emph{subject} for its latest state and act accordingly to its implementation.

The \emph{EventTarget interface}\footnote{\url{https://dom.spec.whatwg.org/\#interface-eventtarget}} of the document object model \emph{(DOM)} API exposed to a browsers JavaScript runtime (among others) is an evolution of the observer pattern.

\begin{listing}[H]
	\mint{JavaScript}{window.addEventListener('click', e => console.log('click', e.target));}
	\caption{Add a click handler to the \mintinline{JavaScript}{window} event target (JavaScript)}
	\label{lst:eventtarget}
\end{listing}

The code in listing \ref{lst:eventtarget} shows how an event handler (the \emph{observer}) can register for events emitted by an event target (the \emph{subject}). Registered event handlers will be called one after another once the event target dispatches (\emph{notifies}) an event. The handler shown gains access to the \emph{subjects} state through the \mintinline{JavaScript}{target} property of the function parameter \mintinline{JavaScript}{e}.


\section{Revisit the Paper}

Salvaneschi et al. start with a broad overview on RP, its history, how it came to be and why it is determined as a trend in computer science for some time. Right from the start the term reactive application is defined as a piece of software which reacts continuously on stimuli of different origins. These events are either rooted in a technical system component or triggered by a human user, for example when interacting with a GUI.

\subsection{Motivation}
We get a summary of the similarities and differences of RP and the observer design pattern, chosen as representative for the OOP paradigm, within the first page. Salvaneschi et al. show benefits and potential problems of both. More concrete examples of RP and the observer pattern are given later in section 2. The papers main hypothesis is derived from the RP/OOP comparison, underpinned with external references: ``\emph{(...) it has been repeatedly argued that RP greatly improves over the traditional Observer pattern used in Object-oriented (OO) programming both (i) from the software design perspective as well as (ii) from the respective of facilitating comprehension of software.}'' Hence the lack of sufficient empirical evidence is then stated as motivation for the study at hand.

\subsection{Study Design}
Salvaneschi et al. formulate the following four research questions which they then use to build their study setup upon:

\begin{itemize}
	\item \emph{Does reactive programming impact the correctness of program comprehension?}
	\item \emph{Does reactive programming impact time for program comprehension?}
	\item \emph{Does comprehending RP programs require a different programming skills level than the OO style?}
	\item \emph{What are the reasons for a difference - if a any - in comprehending RP programs and OO programs?}
\end{itemize}

The first three research questions were evaluated in an experiment with a small group of 38 subjects in an earlier study \cite{Salvaneschi:2014:ESP:2635868.2635895} already. The new study at hand adds 89 new subjects contributing more statistical significance. The new research question 4 targets to further interpret insights gained from the preceding questions and study.

The research group structured its study in two parts: Within limited time, (i) part one asks two groups of subjects in an experiment to interpret either ten RP or ten OOP code samples and answer questions regarding the expected behavior. Code samples were formulated in Scala\footnote{\url{https://scala-lang.org/}}, using REScala\footnote{\url{http://www.rescala-lang.com/}} for RP. This is followed by (ii) a survey of four quantitative and one qualitative question where subjects can give their opinion on comprehensibility of RP and OOP source code.

The comprehensibility part uses code examples from three different areas as defined by Salvaneschi et al.: Four questions are \emph{synthetic applications}, code describing pure data flow and the transformation of values. The six other questions are cases for \emph{graphical animations} and \emph{interactive applications}, hence all related to GUI engineering/development. Combined with a time limit, part one contributed to answer the first through to the third research question.

The subject population consisted exclusively of students from a software engineering course, both taught in OOP and the observer pattern as well as RP. Before going into the actual study, the total of 127 subjects were put through a quantitative self-assessment to measure the overall programming skill level of the population. This was necessary to get the subjects acquainted with the survey tool used on one hand, on the other to collect data to answer their third research question.

\subsection{Results and Outlook}

Salvaneschi et al. processed the gathered data from their experiment using a variety of statistical tests and derive three main findings: (i) RP increases the correctness of program comprehension; with the exception of two tasks, the RP group outperformed the OO group. Finding (ii) determines that RP style code does not require more time than comprehending their OO equivalent. With finding (iii) the group finally claims that understanding reactive applications written with RP are overall easier to understand, regardless of the individual programming skill level of the subject.

The further evaluation of the survey provides then a mainly positive result in favor for RP. Beside the quantitative answers given by the subjects, especially the detailed examination of the qualitative gives an insight on the reasoning in why subjects may prefer RP over OOP or vice versa. Where subjects favoring RP speak up for overall more concise and easier composable code, subjects preferring OOP and the observer pattern do not like a steep learning curve and the hidden layer of abstraction given by the RP runtime.

Indeed the research team agrees later that the hidden complexity of the RP runtime and a large API surface area, i.e. with many specialized conversion functions, might not make it easy to onboard a developer with minimal or no RP experience.

With the outlook Salvaneschi et al. conclude the result evaluation with three suggestions for potential follow-up research:

\begin{itemize}
	\item \textbf{Interpretation of the results} connects the comprehension results with related research from psychology. They reference two respective three different cognitive models: \emph{top-down}, \emph{bottom-up} and the \emph{program model}. In context, each describes how a subject might perceive either RP or OOP source code. Designing a study focusing on this area would give deeper insight in how different programming concepts are understood from a psychological point of view. \textbf{REPHRASE}
	\item The \textbf{language design} (API surface area, number of combinators) plays an important role in order to make resulting code more comprehensible. The research group sees potential for further studies which investigate and compare how different languages and frameworks support or lessen the comprehensibility of RP code.
	\item To understand how programmers work will eventually lead to improved \textbf{tool support} i.e. in IDEs. Reactive applications using RP or OOP can be visualized using a graph showing dependencies of values to each other. Hence the potential of a uniform way to interpret reactive code, no matter what paradigm it uses, might be worth of further research.
\end{itemize}

\subsection{Threats to Validity}

Within the section \emph{Threats to Validity}, Salvaneschi et al. an overview of factors which could have pulled or pushed their results into one or another direction. They give insight in how they tried to minimize those influences, if possible. Neglecting \emph{construct} and \emph{internal validity}, the group identifies five issues related to \emph{external validity}: (i) Comparing two programming paradigms depends on an individuals programming skill level. Though a bias towards RP can be desisted, the study's result shows a favorable tendency towards RP in the end. (ii) The code examples used throughout the comprehension task try to cover the main areas of reactive applications. Hence these samples were carefully crafted to avoid giving away correct answers to easily, it is still questionable how representative for real-world applications they are. The research group members tried to minimize this thread by code review and iterative improvement. (iii) The experiment was conducted with student subjects solely. Though differences to more experienced developers can be considered as not significant as a cited study \cite{DiPenta} indicates. (iv) Finally the selection of Scala and REScala can be challenged to be representative for comprehending RP code overall. The selection was satisfying for this study though since the subjects were all exposed the same amount to these technologies and provides common foundation for the experiment.


\section{Paper Review}

\subsection{Application of Empirical Research Methods}

The main part of the study was conducted through an experiment. With its fixed-design setup, quantitative data was collected and evaluated. With the survey ran upfront, they collected further quantitative data regarding the programming skill level of their subject population, but also ensured all participants were familiar with the software used in the main study. This precaution by Salvaneschi et al. ensured that the final experiment was not biased by unfamiliarity with the setup.

The experiment was followed by another survey consisting of four quantitative and one open, qualitative question. Again, this survey was carefully structured so the open question could potentially be answered as unbiased as possible as the research group emphasize in their report.

It is crucible for later revalidation of the presented results to reproduce the described study setup. The questions used in the afterwards survey are available in section 5.2 of the report. Though code examples from the experiment, questions used in the preparation survey nor the survey software are provided.

The paper does not give any explicit indication of the application of concepts and approaches defined by design science. Hence if we understand the  study at hand as the next, refined iteration of the preceding work by Salvaneschi et al. \cite{Salvaneschi:2014:ESP:2635868.2635895}, we could deduce the application of such principles on a higher level.

The study applied empirical research methods carefully and in a valid way overall. Hence the unavailability of mentioned complementary information makes the reproducibility at a later point hard if not impossible when it cannot be retrieved at all.

\subsection{Application of FAIR Research Principles}

The paper has a unique digital object identifier (\emph{DOI}) assigned and is, given necessary access permissions are granted, available online via the IEEE Xplore Online Library\footnote{\url{https://ieeexplore.ieee.org}}. This platform provides extensive meta information like citations, keywords or other work referencing the paper. By doing so, the research report conforms fully with criteria for \emph{Findability} and \emph{Accessibility}. We can further confirm that in regards of \emph{Interoperability} only domain-specific, accepted vocabularies and language is used. Qualified references to the work of third parties are present.

This research report itself does not state an explicit license for reuse. The examination of available meta information in the IEEE Xplore Online Library finally reveals that the IEEE organization holds full copyrights on the report. Reuse permission can be requested. As already highlighted in the previous section, complementary objects like the experiments code samples or the complete survey questionnaires are not available. Though the report does fundamentally conform with the concepts of \emph{Reusability} by providing rich meta information, preceding points violate the concept of FAIR research in these regards.

To further align the results at hand with FAIR research principles, we suggest to (i) state license information more explicitly and (ii) provide (at least) the code samples and questionnaires from the preliminary survey along with the report. If the software used throughout the experiment and surveys would be available too, the value for the science community could be further increased.

\subsection{RP and OOP}


\begin{itemize}
	\item \textbf{Critique 5: Page 8 switchOnce was not understandable for all subjects; Observable code might have been better comprehensible. This contradicts Finding 3, where they say RP code needs a potential lower programming skill level}
	\item \textbf{Critique: Page 14: Renaming variables to neutral things ... Real situation?}
	\item \textbf{Critique: Page 15: External Validity: Short RP training: Hype factor: WOW THATS NEW!}
\end{itemize}


\begin{itemize}
	\item \textbf{Critique 4: Page 4 defines grapics and UI as traditional domains for RP; is it representative to use mainly traditional domains to challenge RP with observer? ... like: what about "using the right tool for the right thing"?}
	\item \textbf{Critique 1: The paper title might hope for RP topic in general, but it is soon clear that we mostly compare with UI releated stuff}
	\item \textbf{Critique 2: OOP solutions for reactivity are reduces to the observer pattern. The paper misses the opportunity ti mention other approaches}
\end{itemize}


\begin{itemize}
	\item \textbf{Check: Claim Page 12 Observer Pattern does not provide separation of concerns}
	\item \textbf{Critique: Page 13 and 14: Why suddently an analogy to operating system architecture?}
\end{itemize}

\section{Discussion}
Given the results, I will put RP in context with current trends in software engineering, in particular in its subdiscipline web frontend engineering.
Ideas: RxJS, BaconJS, Elm, ReactJS \dots tbd.

\begin{itemize}
	\item \textbf{Pick Up: Toolsupport Rxjs}
	\item \textbf{Pick Up: ECMAScript Streams}
	\item \textbf{Cite page 13 about operator complexity... Own experience: Yes, it is cumbersome}
\end{itemize}


\section{Conclusion}


\bibliographystyle{splncs04}
\bibliography{index}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.

\end{document}