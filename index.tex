\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{tabularx}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.3 PREPUBLISH}


\begin{document}
\begin{centering}
	\Large{Master Seminar}
	\par
	\Huge{Reactive Applications in\\Frontend Engineering Today}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Olaf Zimmermann\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\noindent\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{2ex}

		\small{
			\noindent\textbf{Keywords}: Frontend Engineering, Reactive Programming, Object Oriented Programming, Design Science, Empirical Software Engineering, FAIR Research Principles
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}
Solving unique problems through the application of software engineering principles does not lead to unique solutions in general. In fact, the emergence of recurring design patterns can be observed. Salvaneschi et al. \cite{7827078} challenge the Observer design pattern \cite{gamma1995design}, having its origin in object oriented programming \emph{(OOP)}, and its impact on source code comprehensibility in comparison to the usage of reactive programming \emph{(RP)}.

We will examine the work by Salvaneschi et al. titled \emph{``On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study''} \cite{7827078} and answer two sets of research questions. With a focus on design sciences and empirical software engineering methods, set \emph{RQ1} considers the following three questions:

\begin{itemize}
	\item \emph{RQ1.1: Which empirical research methods, approaches and concepts were applied by Salvaneschi et al. \cite{7827078}?}
	\item \emph{RQ1.2: Are these research methods, approaches and concepts applied well, what could have been done better?}
	\item \emph{RQ1.3: Do Salvaneschi et al. \cite{7827078} meet FAIR principles \cite{2019arXiv190805986H} \cite{wilkinson:2016} with their work?}
\end{itemize}

Since the paper under inspection compares RP with the Observer design pattern, the second question set \emph{RQ2} reviews software engineering specific aspects of that comparison:

\begin{itemize}
	\item \emph{RQ2.1: How do Salvaneschi et al. \cite{7827078} define RP and OOP?}
	\item \emph{RQ2.2: When should RP be considered, and when not?}
	\item \emph{RQ2.3: Which experiments should be conducted in future work?}
	\item \emph{RQ2.4: Which design alternatives exist in the context of frontend engineering?}
\end{itemize}

In the following we will first introduce and clarify important terms. Section \ref{sec:summary} then starts with a summary, Section \ref{sec:review} follows with the review of Salvaneschi et al. and answer \emph{RQ1}/\emph{RQ2.1}. The questions \emph{RQ2.2} through \emph{2.4} will be tackled in Section \ref{sec:practical-application} where we discuss earlier findings in context of frontend engineering. How Salvaneschi et al. applied statistical methods on their results are out of scope and not part of this work.

\subsection{Empirical Software Engineering}

Software engineering applies engineering principles when working with software artifacts \cite{159342} throughout their life cycle. Although ``\emph{the application of a systematic, disciplined, quantifiable approach to the development (\dots) of software (\dots)}'' \cite{159342} may rightfully restrain us methodically, it is agreed upon that the process leading to a software product is of creative nature \cite{8051350} and hard to measure.

Where the software engineering process lacks scientific and analytical formalism, empirical software engineering acknowledges this by applying empirical research methods. Kapferer \cite{kapferer:2019:empirical} exemplifies the application of empirical software engineering in his introductory paper. He investigates on the similarities of the empirical research cycle and iterative quality improvement processes like \emph{Plan/Do/Study/Act} \cite{deming} or agile project setups with \emph{Scrum}.

\subsection{Design Science}

Roel J. Wieranga derives guidelines specifically for software engineering research projects from design science in his book \emph{Design Science Methodology for Information Systems and Software Engineering} \cite{wieringa}. As Balestra \cite{balestra:2019:designscience:articactandcontext} summarizes in his paper about design science and their application in software projects, Wieranga \cite{wieringa} defines an iterative process consisting of a \emph{design} and \emph{investigation} step. During \emph{design}, an \emph{artifact} is designed to satisfy the goals of one or more \emph{stakeholders} under consideration of a specific \emph{knowledge context}. The artifact and context is then put under \emph{investigation} to answer knowledge questions. These answers lead to a feedback loop where gained insights get fed into another design iteration. This process might be repeated until the stakeholder goals are met at a satisfying level.

\subsection{FAIR Research Principles}
\label{sec:fair}

\emph{FAIR} is an abbreviation for Findability, Accessibility, Interoperability and Reusability. It was first introduced by Mark. D. Wilkinson et al. in March 2016 \cite{wilkinson:2016} and describes guidelines to foster digital research objects over the long-term. The guidelines want to maximize the value of research results for the science community as a whole. Following a summary of the four cornerstones:

\begin{itemize}
	\item \emph{Findability}: Objects are annotated with well-defined meta information. This information is usable for both humans and machines. An example is a globally unique, persistent identifier for a publicized paper or keywords highlighting the problem domains of a research result. There is a catalogue which provides searchable access to this meta information.
	\item \emph{Accessibility}: Digital objects can be retrieved using an open, standardized communication protocol. It provides ways to authenticate and/or authorize users (again both humans and machines) if necessary. Meta information is always available, even if the actual object might not be anymore.
	\item \emph{Interoperability}: Meta information and the object it describes use formats and vocabularies following FAIR principles. For example an accepted, domain specific terminology is used or a data set collected during an experiment is available in XML format, alongside with a schema \footnote{\url{https://www.w3.org/TR/xmlschema-1/}} describing its structure. Referenced research results are part of the meta information.
	\item \emph{Reusability}: Research results meet the respective science communities standards. Results are released under a concise and accessible data usage license to simplify their reuse in follow-up research projects.
\end{itemize}

Hasselbring et al. \cite{2019arXiv190805986H} transfer these general applicable guidelines to the field of computer science research and formulate domain specific recommendations. Their key point is the request for treating software artifacts produced during a research project with the same level of care as the project report itself. Platforms like Zenodo\footnote{\url{https://zenodo.org}} in conjunction with GitHub\footnote{\url{https://github.com}} allow to reference, archive and later retrieve associated software artifacts for example.

\subsection{Modern JavaScript Grammar}
We will use a modern JavaScript dialect (ECMAScript 2017\footnote{\url{https://www.ecma-international.org/ecma-262/8.0/}}) for all code listings exclusively. We do not expect our readers to be fluent in this language and therefore provide a quick overview of the most important language features they will encounter in this paper in Appendix \ref{sec:modern-javascript-grammar}.

\subsection{Reactive Programming}
RP is a declarative programming paradigm. In contrary to imperative programming, declarative code describes \emph{what} should be achieved rather than \emph{how} the process leading to that result looks like. With RP, we describe values, their transformation over time and how they depend on each other \cite{8354906}. A runtime system propagates changed values to their relevant dependencies, execute declared computations and ensures always a consistent state.

Listing \ref{lst:rp-with-baconjs} shows an implementation for continuously displaying the upper case value of a text field in an output area using the RP runtime of \emph{BaconJS}\footnote{\url{http://baconjs.github.io/}}.

\begin{listing}[H]
	\begin{minted}{JavaScript}
		Bacon
			.fromEvent(getTextField(), "keyup")
			.debounce(300)
			.map(({ target: { value }}) => value)
			.map(value => value.toUpperCase())
			.onValue(value => setOutput(value));
	\end{minted}
	\caption{Display the upper case value of a text field with BaconJS if not changed for 300 milliseconds}
	\label{lst:rp-with-baconjs}
\end{listing}

Line 1 subscribes to key events triggered every time the user releases a key. In case the user types a long text, the \mintinline{JavaScript}{debounce} combinator on line 2 prevents downstream computations being executed too many times. Once the user stopped typing for at least 300 milliseconds, the \mintinline{JavaScript}{map} combinator is used to extract the fields current value (line 4) as well as for transforming the value to an upper case string (line 5). Line 6 finally displays the resulting string using a side effect.

\subsection{Observer Design Pattern}
When dividing a large component into smaller sub components, we usually want these components to be as isolated as necessary so they become more reusable, hence target for loose coupling between them. Still, the new components need a way to interact with each other.

The Observer pattern \cite{gamma1995design} is deeply rooted in OOP and defines an interface where \emph{observers} can subscribe to state change notifications of a \emph{subject}. Once notified, an \emph{observer} might query the \emph{subject} for its latest state and act accordingly to its implementation. The \emph{EventTarget interface}\footnote{\url{https://dom.spec.whatwg.org/\#interface-eventtarget}}, part of the Document Object Model \emph{(DOM)} API, is an evolution of the Observer pattern. It allows modern JavaScript engines to hook into a browsers internal data model. This interface is used in Listing \ref{lst:eventtarget} to implement functionality presented in the previous subsection again:

\begin{listing}[H]
	\begin{minted}{JavaScript}
		getTextField().addEventListener(
			"keyup",
			debounce(
				({ target: { value }}) => setOutput(value.toUpperCase()),
				300
			)
		);
	\end{minted}
	\caption{Display the upper case value of a text field using the Observer implementation of \emph{EventTarget} if not changed for 300 milliseconds}
	\label{lst:eventtarget}
\end{listing}

Since text fields implement the EventTarget interface, we are able to register a key event handler using \mintinline{JavaScript}{addEventListener} on line 1-2. We use \mintinline{JavaScript}{debounce} on line 3 and compose our actual event handler callback (line 4) accordingly. Doing so ensures that the actual callback will only be executed once the user stopped typing for 300 milliseconds (line 5). We get access to the text fields current value by accessing the provided \mintinline{JavaScript}{Event} parameter on line 3 and call then \mintinline{JavaScript}{setOutput} with the upper case version of the text on line 4.

\section{Summary of Salvaneschi et al.}
\label{sec:summary}

Salvaneschi et al. start with a broad overview on RP, its history, how it came to be and why it is determined as a trend in computer science for some time. The term reactive application is defined as a piece of software which reacts continuously on stimuli of different origins. These events are either originated in a technical system component or triggered by a human user, for example when interacting with a GUI.

\subsection{Motivation}
The research group elaborates similarities and differences of RP and the Observer design pattern, chosen as representative for the OOP paradigm, within the first page. They show benefits and potential problems of both. More concrete examples of RP and the Observer pattern are given later in Section 2. The papers main hypothesis is derived from the RP/OOP comparison, underpinned with external references: ``\emph{(...) it has been repeatedly argued that RP greatly improves over the traditional Observer pattern used in Object-oriented (OO) programming both (i) from the software design perspective as well as (ii) from the respective of facilitating comprehension of software.}'' Hence the lack of sufficient empirical evidence is then stated as motivation for the study at hand.

\subsection{Study Design}
Salvaneschi et al. formulate the following four research questions which they then use to build their study setup upon:

\begin{itemize}
	\item \emph{``Does reactive programming impact the correctness of program comprehension?''}
	\item \emph{``Does reactive programming impact time for program comprehension?''}
	\item \emph{``Does comprehending RP programs require a different programming skills level than the OO style?''}
	\item \emph{``What are the reasons for a difference - if a any - in comprehending RP programs and OO programs?''}
\end{itemize}

The first three research questions were evaluated in an experiment with a small group of 38 subjects in an earlier study \cite{Salvaneschi:2014:ESP:2635868.2635895} already. The new study at hand adds 89 new subjects contributing more statistical significance. Research question 4 targets to improve the interpretation of insights gained from the preceding questions and study.

The research group structured its study in two parts: Within limited time, (i) part one asks two groups of subjects in an experiment to interpret either ten RP or ten OOP code samples and answer questions regarding the expected behavior. Code samples were formulated in Scala\footnote{\url{https://scala-lang.org/}}, using REScala\footnote{\url{http://www.rescala-lang.com/}} for RP. This is followed by (ii) a survey of four quantitative and one qualitative question where subjects can give their opinion on comprehensibility of RP and OOP source code.

The comprehensibility part uses code examples from three different areas as defined by Salvaneschi et al.: Four questions are \emph{synthetic applications}, code describing pure data flow and the transformation of values. The six other questions are cases for \emph{graphical animations} and \emph{interactive applications}, hence all related to GUI engineering/development. Combined with a time limit, part one contributed to answer the first three research question.

The subject population consisted exclusively of students from a software engineering course, both taught in OOP and the Observer pattern as well as RP. Before going into the actual study, the total of 127 subjects were put through a quantitative self-assessment to measure the overall programming skill level of the population. This was necessary to get the subjects acquainted with the survey tool used on one hand, on the other to collect data to answer the third research question.

\subsection{Results and Outlook}

Salvaneschi et al. processed the gathered data using a variety of statistical tests and derive three main findings: (i) RP increases the correctness of program comprehension; with the exception of two tasks, the RP group outperformed the OO group. Finding (ii) determines that RP style code does not require more time than comprehending their OO equivalent. With finding (iii) the group finally claims that understanding reactive applications written with RP are overall easier to understand, regardless of the individual programming skill level of the subject.

Further evaluation of the survey shows a mainly positive result in favor of RP. Beside the quantitative answers given by the subjects, especially the detailed examination of the qualitative ones give an insight on the reasoning in why subjects may prefer RP over OOP or vice versa. Where subjects favoring RP speak up for overall more concise and easier composable code, subjects preferring OOP and the Observer pattern do not like the steep learning curve and the hidden layer of abstraction given by the RP runtime.

The research team agrees later that the hidden complexity of the RP runtime and a large API surface area, i.e. with many specialized conversion functions, might not make it easy to onboard a developer with minimal or no RP experience.

The result evaluation is concluded with the outlook and three suggestions for potential follow-up research:

\begin{itemize}
	\item Psychology knows multiple models to describe the process of \emph{comprehending} a circumstance. Salvaneschi et al. reference in \textbf{interpretation of the results} three of these models (\emph{top-down}, \emph{bottom-up} and \emph{program model}). In context, each describes how a subject might perceive either RP or OOP source code. A study focusing on the psychological aspects of code comprehension could give a new perspective on how code, RP or OOP likewise, is perceived mentally.
	\item The \textbf{language design} (API surface area, number of combinators) plays an important role in order to make resulting code more comprehensible. The research group sees potential for further studies which investigate and compare how different languages and frameworks support or lessen the comprehensibility of RP code.
	\item To understand how programmers work will eventually lead to improved \textbf{tool support} i.e. in IDEs. Reactive applications using RP or OOP can be visualized using a graph showing dependencies of values to each other. Hence the potential of a uniform way to interpret reactive code, no matter what paradigm it uses, might be worth of further research.
\end{itemize}

\subsection{Threats to Validity}

Within the Section \emph{Threats to Validity}, Salvaneschi et al. present an overview of factors which could have pulled or pushed their results into one or another direction. They give insight in how they tried to minimize those influences, if possible. Neglecting \emph{construct} and \emph{internal validity}, the group identifies five issues related to \emph{external validity}: (i) Comparing two programming paradigms depends on an individuals programming skill level. Though a bias towards RP can be desisted, the study's result shows a favorable tendency towards RP in the end. (ii) The code examples used throughout the comprehension task try to cover the main areas of reactive applications. Hence these samples were carefully crafted to avoid giving away correct answers to easily, it is still questionable how representative for real-world applications they are. The research group members tried to minimize this threat through code reviews and iterative improvements. (iii) The experiment was conducted with student subjects solely. Though differences to more experienced developers can be considered as not significant as a cited study \cite{DiPenta} indicates. The section finally concludes with the question (iv) if Scala and REScala should be challenged as good choice to represent RP overall. The research group arguments that the selection was satisfying for their study since all subjects were exposed the same level to these technologies in advance.

\section{Review of Salvaneschi et al.}
\label{sec:review}

\subsection{Application of Empirical Research Methods}

The main part of the study was conducted through a controlled experiment. With its fixed-design setup, quantitative data was collected and evaluated. With the survey ran upfront, Salvaneschi et al. collected quantitative data regarding the programming skill level of their subject population. The research group ensured all participants were familiar with the survey software used in the main study. This precaution allowed them to conduct the main experiment without a negative bias caused by unfamiliarity with the survey tool.

The experiment was followed by another survey consisting of four quantitative and one open, qualitative question. Again, this survey was carefully structured so the open question could potentially be answered as unbiased as possible as the research group emphasize in their report.

It is crucible for later revalidation of the presented results to reproduce the described study setup. The questions used in the afterwards survey are available in Section 5.2 of the report. Unfortunately code examples from the experiment, questions used in the preparation survey nor the survey software itself are provided.

The paper does not give any explicit indication of the application of concepts and approaches known from design science. Since this is not the first study in the field of RP by Salvaneschi et al. (i.e. preceding work \cite{Salvaneschi:2014:ESP:2635868.2635895}), we could assume that such concepts were applied on a \emph{higher} planning level to iterate on previous results. We cannot proof this because of the mentioned lack of concrete evidence though.

The study applied empirical research methods carefully and in a valid way overall. Hence the unavailability of mentioned complementary information makes the reproducibility at a later point hard if not impossible in case it cannot be retrieved at all.

\subsection{Application of FAIR Research Principles}

The paper has a unique digital object identifier (\emph{DOI}) assigned and is, given necessary access permissions are granted, available online via the IEEE Xplore Online Library\footnote{\url{https://ieeexplore.ieee.org}}. This platform provides extensive meta information like citations, keywords or other work referencing the paper. By doing so, the research report conforms fully with criteria for \emph{Findability} and \emph{Accessibility}. We can further confirm that in regards of \emph{Interoperability} only domain-specific, accepted vocabularies and language is used. Qualified references to the work of third parties are present.

This research report itself does not state an explicit license for reuse. The examination of available meta information in the IEEE Xplore Online Library reveals that the IEEE organization holds full copyrights on the report eventually. Reuse permission can be requested. As already highlighted in the previous Section, complementary objects like the experiments code samples or the complete survey questionnaires are not available. Though the report does fundamentally conform with the concepts of \emph{Reusability} by providing rich meta information, preceding points violate the concept of FAIR research.

To further align the results at hand with FAIR research principles, we suggest to (i) state license information more apparently and (ii) provide (at least) the code samples and questionnaires from the preliminary survey along with the report. If the software used throughout the experiment and surveys would be available too, the value for the science community could be further increased.

\subsection{Reactive vs. Object Oriented Programming}

Before the terms of RP and OOP are introduced, Salvaneschi et al. define the the \emph{reactive application}. This type of application distinguishes itself from a more traditional one-off input-to-output processing by producing a continuous, through interaction ever-changing, flow if information. By their very nature, reactive applications require design patterns to model this steady flow of data in a comprehensible way.

\textbf{Reactive Programming} is thoroughly introduced by mentioning its roots in the Haskell programming language and the traction it gained throughout recent years. The research group hypothesises about readability of reactive code facilitating RP. Further characteristics like the declarative way of describing data flows or baked-in composability inherited from its functional ancestor are noted later in Section 2. The group gives then an overview of how \emph{REScala} implements an API to work with its RP runtime using \mintinline{Scala}{Var}s, \mintinline{Scala}{Signal}s and various combinations of those.

The paradigm of \textbf{Object Oriented Programming} is less prominently introduced compared to its competitor. For its usage in reactive applications, it is quickly reduced to the Observer design pattern. Though the group highlights the decoupling of the observable and its observers as positive, inversion of control and incontrollable side effects in the observers code is noted as negative drawbacks lessen the readability and predictability of resulting source code. Since Scala does not only allow functional-flavored code, OOP code examples are presented in Scala too. We were not able to determine the specific implementation of the Observer pattern used and therefore conclude that the code examples facilitate a theoretical implementation of the design pattern.

Even though Salvaneschi et al. assume in their paper the Observer design pattern as common knowledge in their expert audience, we would have appreciated an introduction on the same level as RP received. The group further reduces the OOP paradigm to one sole case which is disputable. A more differentiated approach where i.e. the patterns root in OOP is noted, but then not used throughout the report as synonym for the pattern itself would have been received well.

\section{Application in Frontend Engineering}
\label{sec:practical-application}

The previously reviewed paper by Salvaneschi et al. explores how RP changes the comprehensibility of code for synthetic and interactive applications as well as for graphical animations \cite{7827078}. Hence all of these problems can ultimately be implemented with RP and the Observer pattern likewise, there is no measure given when the alluded tradeoffs like the additional layer of abstraction (RP) or inversion of control (Observer) outweigh gained benefits. In order to answer the research question \emph{RQ2.2 ``When should RP be considered, and when not?''}, we will present two technical scenarios in context of frontend engineering for synthetic and interactive applications in the following. The current draft of the Web Animations API\footnote{\url{https://drafts.csswg.org/web-animations/}} by the World Wide Web Consortium \emph{(W3C)} or various libraries (i.e. \emph{react-spring}\footnote{\url{https://www.react-spring.io/}}) provide interfaces based on RP principles enabling sophisticated animation behaviors. Since high-performance graphical animations in frontend engineering are most commonly done using CSS Animations\footnote{\url{https://drafts.csswg.org/css-animations-1/}} up to today though, we will not compare the Observer pattern and RP in regards of graphical animations any further.

\subsection{Modelling Data Flow}

\begin{framed}
	\noindent\emph{S1 Modelling Data Flow:} Fetch a users complete profile information (first- and surname as well as their avatar picture) from two distinct data sources (\mintinline{JavaScript}{fetchProfile} and \mintinline{JavaScript}{fetchAvatar}). The profile information contains required input to fetch the avatar. Show the combined information in the UI at once using \mintinline{JavaScript}{renderUser}.
\end{framed}

The first scenario of a \emph{synthetic application} \cite{7827078} describes a common problem where the information from a remote resource needs to be combined with another one. The situation gets a bit more complex when the result of the first resource is required as input for the second one. Generally spoken, a solution to this problem describes the flow (fetch one resource after the other) and transformation (combination of both results) of data.

We can implement a solution facilitating a basic RP approach using the \mintinline{JavaScript}{Promise}\footnote{\url{https://www.ecma-international.org/ecma-262/6.0/\#sec-promise-objects}} API available in modern JavaScript runtime environments as exemplified in Listing \ref{lst:data-flow-rp}:

\begin{listing}[H]
	\begin{minted}{JavaScript}
		fetchProfile()
			.then(async (profile) => {
				const avatar = await fetchAvatar(profile);
				return { ...profile, ...avatar };
			})
			.then(renderUser);
	\end{minted}
	\caption{Render user profile using RP with the \mintinline{JavaScript}{Promise} API}
	\label{lst:data-flow-rp}
\end{listing}

The execution of \mintinline{JavaScript}{fetchProfile} on line 1 returns a \mintinline{JavaScript}{Promise} providing basic user profile information. The profile serves as input parameter for \mintinline{JavaScript}{fetchAvatar} which returns another \mintinline{JavaScript}{Promise} (line 3). Once this \mintinline{JavaScript}{Promise} resolves with the avatar picture information, all fetched data is combined and returned (line 4). This data is then finally piped to the \mintinline{JavaScript}{renderUser} function on line 6, which eventually shows the users complete profile information in the user interface.

Listing \ref{lst:data-flow-observer} leverages a custom implementation of the Observer design pattern after Gamma et al. \cite{gamma1995design}, providing the same level of functionality as Listing \ref{lst:data-flow-rp} did using RP.

\begin{listing}[H]
	\begin{minted}{JavaScript}
		const profileObservable = observable();
		const avatarObservable = observable();

		profileObservable.addObserver(async () => {
			const avatar = await fetchAvatar(profileObservable.value);
			avatarObservable.value = avatar;
			avatarObservable.notify();
		});

		avatarObservable.addObserver(() => {
			renderUser({
				...profileObservable.value,
				...avatarObservable.value
			});
		});

		fetchProfile().then(profile => {
			profileObservable.value = profile;
			profileObservable.notify();
		});
	\end{minted}
	\caption{Render user profile using a custom Observer API}
	\label{lst:data-flow-observer}
\end{listing}

After two observables for profile and avatar information are created (lines 1-2), an observer on the \mintinline{JavaScript}{profileObservable} is registered on line 4. Given callback function will wait for \mintinline{JavaScript}{fetchAvatar} resolving with the requested information. Notice here how the functions parameter is referenced from \mintinline{JavaScript}{profileObservable}s current \mintinline{JavaScript}{value} (line 5). Once the avatar information is available, it is stored (line 6) and the observer registered on line 10 is executed by calling \mintinline{JavaScript}{notify} (line 7). This observer (lines 10-15) combines the current values of both observables and calls \mintinline{JavaScript}{renderUser}. On line 17, \mintinline{JavaScript}{fetchProfile} is finally called. Once the returned \mintinline{JavaScript}{Promise} resolves with the \mintinline{JavaScript}{profile}, it is kept as \mintinline{JavaScript}{profileObservable}s \mintinline{JavaScript}{value} (line 18) and the observer from line 4 is executed through another \mintinline{JavaScript}{notify} call (line 19).

By sole comparison of the line count of both presented solutions, the results of Salvaneschi et al. \cite{7827078} regarding reduced boilerplate code through RP are confirmed. Whereas the Observer example needs to implement code for handling \mintinline{JavaScript}{fetchProfile}s result (line 5) before the function itself is even called (line 17), the RP implementation reflects the mental model of fetching one depending resource after its predecessor more concisely further.

\subsection{Handle User Interaction}

The \emph{interactive application} \cite{7827078} described in the second scenario is rather simple in its formulation, though represents the recurring common task of handling user interaction events when building a frontend application:

\begin{framed}
	\noindent\emph{S2 Handle User Interaction:} Handle clicks on a button available through \mintinline{JavaScript}{getButton}. Every time a user clicks the button, log the current time using \mintinline{JavaScript}{logInteraction}. The log shows a list of all user interactions eventually.
\end{framed}

Listing \ref{lst:event-handling-observer} shows a straight forward implementation for this problem in an arbitrary browser using the builtin, Observer based \mintinline{JavaScript}{EventTarget} interface.

\begin{listing}[H]
	\begin{minted}{JavaScript}
		getButton().addEventListener("click", () => logInteraction(new Date()));
	\end{minted}
	\caption{Log user interaction using \mintinline{JavaScript}{EventTarget} interface}
	\label{lst:event-handling-observer}
\end{listing}

After the handle on the button was acquired using \mintinline{JavaScript}{getButton}, a callback function is registered as observer using \mintinline{JavaScript}{addEventListener}. This function will be executed each time the button emits a click event, hence the user clicked the button. By doing so, \mintinline{JavaScript}{logInteraction} will be called with the current time represented by a new instance of \mintinline{JavaScript}{Date}.

An RP based solution using \emph{BaconJS} is shown in the following Listing \ref{lst:event-handling-rp}:

\begin{listing}[H]
	\begin{minted}{JavaScript}
		Bacon.fromEvent(getButton(), "click")
			.map(() => new Date())
			.onValue(logInteraction);
	\end{minted}
	\caption{Log user interaction using a BaconJS \mintinline{JavaScript}{EventStream}}
	\label{lst:event-handling-rp}
\end{listing}

Similar to the Observer design pattern approach shown in Listing \ref{lst:event-handling-observer} where we used \mintinline{JavaScript}{addEventListener} to register an observer, we use \mintinline{JavaScript}{fromEvent} to hook up to click events of the button provided by \mintinline{JavaScript}{getButton} on line 1. Here, \mintinline{JavaScript}{fromEvent} creates an \mintinline{JavaScript}{EventStream}\footnote{\url{https://baconjs.github.io/api3/classes/eventstream.html}} of click events. Each of these events get transformed to a new \mintinline{JavaScript}{Date} instance using the the \mintinline{JavaScript}{map} combinator (line 2). Line 3 subscribes to these \mintinline{JavaScript}{Date} instances by passing \mintinline{JavaScript}{logInteraction} as subscriber to \mintinline{JavaScript}{onValue} which will log the users button interactions.

Both the Observer and RP based implementation show a simplistic solution for S2. Though each look similar in essence, the RP approach using \emph{BaconJS} implies a lot of additional work behind the scene since it has to create and maintain the \mintinline{JavaScript}{EventStream} abstraction. Embracing the Observer design pattern without any detour, Listing \ref{lst:event-handling-observer} registers its observer using \mintinline{JavaScript}{addEventListener} straight away and implements necessary logic to call \mintinline{JavaScript}{logInteraction} in place.


\subsection{When RP? When Observer?}
\label{sec:when-rp-when-observer}

With S1 and S2 we saw two examples how RP and the Observer design pattern can lead to solutions for the same problem. S1 confirms the most important findings regarding benefits of RP by Salvaneschi et al.: Boilerplate code is reduced significantly and the declarative way of describing data flows improves on the comprehensibility of the source code. We can affirm this further by our own experience during the construction of the examples: Refactoring the Observer based code was more prone to runtime errors because of its fragmented nature.

S2 contrasts with S1 strongly by intention. The problem is more simplistic on one hand, on the other it might look unfair to apply RP on an API already leveraging the Observer pattern like \mintinline{JavaScript}{EventTarget} does. Indeed we argue that applying RP just for the sake of it is dangerous on the long run. Introducing hidden complexity (i.e. creating an \mintinline{JavaScript}{EventStream} using \mintinline{JavaScript}{fromEvent}) does not improve the source code itself nor its comprehensibility in any way. In fact it will eventually make debugging problems harder down the road.

So, when should RP used and when should the Observer design pattern be applied ultimately? We refuse to take position for one or the other. Hence we support that RP code is more comprehensible when it comes to the description of complex succession of data transformations over time as Salvaneschi et al. proofed in their study. In contrary we also cannot approve its blind application for every problem given. As exemplified with S2 previously, there are situations where the Observer pattern has its benefits over RP too.

This absence of any solid argumentation leaves the individual engineer facing the choice between the Observer pattern and RP with a lot of room for interpretation. We attempt to improve on this situation by providing a set of criteria with Table \ref{tab:criteria}. Each criterion states one or more questions. We do not intend to give simple \emph{``if-this-then-that''} recipes though. In fact, these questions purpose are to initiate valuable discussions when a team faces the decision between the Observer pattern and RP.

\begin{table}[H]
	\begin{tabularx}{\textwidth}{ |l|X| }
		\hline
		\textbf{Cardinality}      & How many components consume emitted values? Are there many? Is there only one? \\ \hline
		\textbf{Change Frequency} & How many values are expected to emitted over time?\\ \hline
		\textbf{Stimuli Source}   & Where do emitted values come from? Are they triggered by user interaction? Do they originate in an external system which we subscribe to? Which paradigms do these sources build their API upon? \\ \hline
		\textbf{Testability}      & Is it enough to apply black box testing to your implementation? Do you want to break a more complex implementation apart and test each component individually? \\ \hline
		\textbf{Transformation}   & How complex are the transformations which need to be applied on emitted values? Are values from multiple sources needed to be combined? What are the requirements of these combinations?\\ \hline
	\end{tabularx}
	\caption{Criteria Catalog ``Decision Observer or RP''}
	\label{tab:criteria}
\end{table}


\subsection{Alternatives}

The DOM API uses the Observer design pattern with the \mintinline{JavaScript}{EventTarget} interface extensively as we demonstrated repeatedly. The JavaScript \mintinline{JavaScript}{Promise} leverages RP for its API and can be used to describe asynchronous operations since the wide adoption of its specification by major browsers and JavaScript engines. We are convinced that neither the Observer pattern nor RP are easily to be replaced in the field of frontend engineering. We were further not able to identify any trends for a concrete alternative at the time of writing this paper.

\subsection{Outlook}

We hypothesised about when the application of RP might be worth or when better stick with a more traditional Observer pattern based approach in the previous Subsection \ref{sec:when-rp-when-observer}. A study providing empirical insight in the matter of the presented scenarios and decision criteria in Table \ref{tab:criteria} could yield valuable results to support software projects facing the question stated in \emph{RQ2.2}.

The implementation of high-performance graphical animations in frontend engineering is usually done with CSS Animations today. It allows the implementation of simple transitions in an easy way. More complex animations which need to be synchronized to the applications logic demand for more sophisticated APIs than CSS Animations provides. JavaScript libraries like \emph{react-spring} do provide such RP based APIs today, though cannot calculate animated values as efficient as the browsers own CSS engine can. The W3C has a promising draft for the Web Animations API in development. We are certain that this would be an interesting area for future research.

Our own experiences using RP for developing frontend applications using \emph{RxJS}\footnote{\url{https://rxjs.dev/}} resonates well with one of the proposed follow up topics by Salvaneschi et al.: ``\emph{Understanding how programmers work is fundamental to provide better tool support, especially IDEs, a research area which is vastly unexplored for RP.}'' \cite{7827078} As the complexity of data flows, their transformations and dependencies increase, the need for better tooling grows likewise. Even though support libraries like \emph{rxjs-spy}\footnote{\url{https://cartant.github.io/rxjs-spy/}} or the inspection capabilities of \emph{BaconJS} do help up to some extent during debugging, we agree with Salvaneschi et al. that improvements in this field could boost the adoption and productivity of RP further.

\section{Conclusion}

With this paper we revisited the study of Salvaneschi et al. \cite{7827078}. We did a review of their work in context of design sciences and empirical software engineering. Furthermore we looked into how their documentation withstands the FAIR research principles and what could be improved in regards of the amendments for computer science research projects proposed by Hasselbring et al. \cite{2019arXiv190805986H}. With Section \ref{sec:practical-application} we finally transferred the work of Salvaneschi et al. to the context of todays frontend engineering. We demonstrated how a solution for two distinct scenarios can be implemented using the Observer design pattern and RP likewise. Because we refused to give fixed recommendations when to use which paradigm or pattern, we presented a criteria catalog with questions serving as a starter for the decision finding process. Section \ref{sec:practical-application} concludes with the proposal of three topics for further research: (i) A study to validate presented scenarios and decision criteria in order to support software projects, (ii) the examination of the W3C draft for the Web Animations API allowing complex high-performance animations and (iii) investing in improved RP debug tooling supporting engineers working in this area.

After writing this paper we decided to make the third topic subject to our own future research in order to gain the masters degree.


\appendix

\section{Modern JavaScript Grammar}
\label{sec:modern-javascript-grammar}

\subsection{Arrow Functions (Lambda Expressions)}
\begin{listing}[H]
	\begin{minted}{JavaScript}
		// Following three function definitions are equivalent:
		function fn(a) {
			return "foo " + a;
		}
		const fn = (a) => "foo " + a;
		const fn = (a) => { return "foo " + a; }
	\end{minted}
	\caption{Fat Arrow Functions}
\end{listing}

\subsection{Spread Operator}
\begin{listing}[H]
	\begin{minted}{JavaScript}
		const objectA = { foo: "bar" };
		const objectB = { baz: true };

		// "Spread"/combine objectA and objectB to result:
		const result = { ...objectA, ...objectB };
		console.log(result); // Outputs { foo: "bar", baz: true }
	\end{minted}
	\caption{Spread Operator}
\end{listing}

\subsection{Object Destructuring}
\begin{listing}[H]
	\begin{minted}{JavaScript}
		const object = { foo: { bar: true } };

		// Destructuring of a variable:
		const { foo: { bar } } = object;
		console.log(bar); // Outputs true

		// Destructuring of function parameter:
		function fn({ foo: { bar } }) {
			return bar;
		}
		fn(object); // Returns true
	\end{minted}
	\caption{Object Destructuring}
\end{listing}

\subsection{Async/Await Syntactic Sugar for Promises}
\begin{listing}[H]
	\begin{minted}{JavaScript}
		// Following two functions are equivalent:
		function fn(promise) {
			return promise.then(result => value.toUpperCase())
		}

		function async fn(promise) {
			const value = await promise;
			return value.toUpperCase();
		}
	\end{minted}
	\caption{Async/Await Syntactic Suger for Promises}
\end{listing}


\bibliographystyle{splncs04}
\bibliography{index}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.


\end{document}