\documentclass[12pt,a4paper]{article}
\usepackage{ccicons}
\usepackage{hyperref}
\usepackage{minted}

\setminted{autogobble=true, tabsize=2, linenos=true, frame=single, breaklines=true}

\newcommand{\version}{v0.1}


\begin{document}
\begin{centering}
	\Huge{tbd. Design Sciences and Empirical Software Engineering / Reactive Programming}
	\par
	\vspace{2ex}

	\normalsize{
		Manuel Alabor\\
		Supervised by Prof. Dr. Olaf Zimmermann\\
		\par
		\vspace{2ex}
		HSR University of Applied Sciences Rapperswil\\
		\par
		\vspace{2ex}
		\today{} (\version)
	}
	\par
	\vspace{2ex}

	\begin{quotation}
		\small{
			\textbf{Abstract}---\input{./abstract.tex}
		}
		\par
		\vspace{2ex}

		\small{
			\textbf{Keywords}: tbd.
		}
		\par
		\vspace{4ex}
	\end{quotation}
\end{centering}

\section{Introduction}
Solving unique problems through the application of software engineering principles does not automatically lead to unique solutions in general. In fact, the emergence of recurring design patterns can be observed. Salvaneschi et al. \cite{7827078} challenge the observer pattern \cite{gamma1995design} and its impact on source code comprehensibility in comparison to the usage of reactive programming \emph{(RP)}.

We will examine the paper \emph{On the Positive Effect of Reactive Programming on Software Comprehension: An Empirical Study} by Salvaneschi et al. \cite{7827078} and answer two sets of questions within this paper. With the focus on  design sciences and empirical software engineering methods, set \textbf{Q1} considers the following three questions:

\begin{itemize}
	\item \textbf{Q1.1}: Which empirical research methods, approaches and concepts were applied?
	\item \textbf{Q1.2}: Are these research methods, approaches and concepts applied well, what could have been done better?
	\item \textbf{Q1.3}: Does the paper meet FAIR principles \cite{2019arXiv190805986H} \cite{wilkinson:2016}?
\end{itemize}

As the paper further compares RP with the observer pattern \cite{gamma1995design}, an equivalent based on object oriented programming \emph{(OOP)} paradigms, question set \textbf{Q2} reviews software engineering specific aspects of that comparison:

\begin{itemize}
	\item \textbf{Q2.1}: How does the paper define RP and OOP?
	\item \textbf{Q2.2}: When should RP be considered, and when not?
	\item \textbf{Q2.3}: Which experiments should be conducted in future work?
	\item \textbf{Q2.4}: Which design alternatives exist (in a particular application context)?
\end{itemize}

In the following we will introduce and clarify important terms. Section 2 and 3 will examine the mentioned paper more closely and answer \textbf{Q1} and \textbf{Q2.1}. The questions \textbf{Q2.2} through \textbf{Q2.4} will be tackled in section 4 where we discuss earlier findings.

\subsection{Empirical Software Engineering}
Software engineering applies engineering principles when working with software artifacts \cite{159342} throughout their life cycle. Although ``\emph{the application of a systematic, disciplined, quantifiable approach to the development (\dots) of software (\dots)}'' \cite{159342} may rightful restrain us methodically, it is agreed upon that the process leading to a software product is of creative nature \cite{8051350}. It is this creative environment that keep the fundamental building blocks of software development, maintenance and operation in a constant flux of change. As tools and methods keep changing \cite{kapferer:2019:empirical}, software engineering organizations need to adapt to new circumstances often. Kapferer \cite{kapferer:2019:empirical} highlights in his introduction to empirical software engineering how the exertion of continuous quality improvement procedures like \emph{Plan/Do/Study/Act} \cite{deming} or an agile project setup like \emph{Scrum} leads to the controlled adoption of such. A reliable benchmark allows an organization to estimate feasibility of a new method or tool in advance as well as measure impact after its implementation.

Hence software engineering problems lack analytical and scientific formalism, empirical software engineering applies empirical research methods in software engineering to yield a representative benchmark for a problem domain.

\subsection{Design Science}

Roel J. Wieranga derives guidelines specifically for software engineering research projects from design science in his book \emph{Design Science Methodology for Information Systems and Software Engineering} \cite{wieringa}. As Balestra \cite{balestra:2019:designscience:articactandcontext} summarizes in his paper about design science and their application in software projects, Wieranga \cite{wieringa} defines an iterative process consisting of a \emph{design} and \emph{investigation} step. During \emph{design}, an \emph{artifact} is designed to satisfy the goals of one or more \emph{stakeholders} under consideration of a specific \emph{knowledge context}. The artifact and context is then put under \emph{investigation} to answer knowledge questions. These answers lead to a feedback loop where gained insights get fed into another design iteration. This process might be repeated until the stakeholder goals are met at a satisfying level.

\subsection{FAIR Research Principles}
\emph{FAIR} is an abbreviation for Findability, Accessibility, Interoperability and Reusability. It was first introduced by Mark. D. Wilkinson et al. in March 2016 \cite{wilkinson:2016} and describes guidelines to foster digital research objects over the long-term. The guidelines want to maximization the value of research results for the science community as a whole. Following a summary of the four cornerstones:

\begin{itemize}
	\item \textbf{Findability}: Objects are annotated with well-defined meta information. This information is usable for both humans and machines. An example is a globally unique, persistent identifier for a publicized paper or keywords highlighting the problem domains of a research result. There is a catalogue which provides searchable access to this meta information.
	\item \textbf{Accessibility}: Digital objects can be retrieved using an open, standardized communication protocol. It provides ways to authenticate and/or authorize users (again both humans and machines) if necessary. Meta information is always available, even if the actual object is not anymore.
	\item \textbf{Interoperability}: Meta information and the object it describes use formats and vocabularies following FAIR principles. For example an accepted, domain specific terminology is used or a data set collected during an experiment is available in XML format, alongside with a schema \footnote{\url{https://www.w3.org/TR/xmlschema-1/}} describing its structure. Referenced research results are part of the meta information.
	\item \textbf{Reusability}: Research results meet the respective science communities standards. Further results are released under a concise and accessible data usage license to simplify their reuse in follow-up research projects.
\end{itemize}

Hasselbring et al. \cite{2019arXiv190805986H} transfer the general applicable guidelines to the field of computer science research and formulate domain specific recommendations. Their key point is the request for treating software artifacts produced during a research project with the same level of care as the project report itself. Platforms like Zenodo\footnote{\url{https://zenodo.org}} in conjunction with GitHub\footnote{\url{https://github.com}} allow to reference, archive and later retrieve associated software artifacts for example.

\subsection{Reactive Programming}
RP is a declarative programming paradigm. In contrary to imperative programming, declarative code describes \emph{what} should be achieved rather than \emph{how} the process leading to that result looks like. With RP, we describe values, their transformation over time and how they depend on each other \cite{8354906}. A runtime system propagates changed values to their relevant dependencies, execute declared computations and ensures always a consistent state.

\begin{listing}[H]
	\begin{minted}{JavaScript}
		// TODO Example RP
	\end{minted}
	\caption{}
	\label{lst:basic-rp-with-rxjs}
\end{listing}

\subsection{Observer Pattern}
When dividing a large component into smaller sub components, we usually want these components to be as isolated as necessary so they become more reusable, hence target for loose coupling between them. Still, the new components need a way to interact with each other.

The observer pattern \cite{gamma1995design} defines an interface where \emph{observers} can subscribe to state change notifications of a \emph{subject}. Once notified, an \emph{observer} might query the \emph{subject} for its latest state and act accordingly to its implementation.

The \emph{EventTarget interface}\footnote{\url{https://dom.spec.whatwg.org/\#interface-eventtarget}} of the document object model \emph{(DOM)} API exposed to a browsers JavaScript runtime (among others) is an evolution of the observer pattern.

\begin{listing}[H]
	\mint{JavaScript}{window.addEventListener('click', e => console.log('click', e.target));}
	\caption{Add a click handler to the \mintinline{JavaScript}{window} event target (JavaScript)}
	\label{lst:eventtarget}
\end{listing}

The code in listing \ref{lst:eventtarget} shows how an event handler (the \emph{observer}) can register for events emitted by an event target (the \emph{subject}). Registered event handlers will be called one after another once the event target dispatches (\emph{notifies}) an event. The handler shown gains access to the \emph{subjects} state through the \mintinline{JavaScript}{target} property of the function parameter \mintinline{JavaScript}{e}.


\section{Artifact Review}
Will not do: Review on statistic

I will assess the paper by Salvaneschi et al. \cite{7827078} in regards of the following aspects:
\begin{itemize}
	\item Applied scientific methods (foundation by Kapferer \cite{kapferer:2019:empirical} and others tbd.)
	\item Study setup
	\item Challenge with FAIR Principles \cite{2019arXiv190805986H} \cite{wilkinson:2016}
\end{itemize}



\section{Review Results}
Is the conclusion of Salvaneschi et al. \cite{7827078} reasonable and well argued?



\section{Discussion}
Given the results, I will put RP in context with current trends in software engineering, in particular in its subdiscipline frontend engineering.
Ideas: RxJS, Elm, ReactJS \dots tbd.

\section{Conclusion}
Summarize findings, give proposal for future work on topic.

\bibliographystyle{splncs04}
\bibliography{index}

\section*{License}
\ccby\thinspace\thinspace This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}.

\end{document}